<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>BrickShooter: iOS Edition (Balanced)</title>
<style>
    body { 
        background:#121212; color:#fff; display:flex; flex-direction:column; 
        align-items:center; font-family:'Segoe UI',sans-serif; 
        overflow:hidden; margin:0; touch-action:none; 
    }
    canvas { 
        border:2px solid #333; background:#080808; 
        max-width: 95vw; max-height: 65vh; 
        box-shadow:0 0 30px rgba(0,0,0,0.8); touch-action:none; 
    }
    .stats { margin:10px; font-size:1.2rem; color:#ffcc00; display:flex; gap:20px; font-weight: bold; }
    .controls { margin-bottom:10px; display:flex; gap:8px; flex-wrap: wrap; justify-content: center; }
    
    button { 
        background:#444; color:white; border:none; padding:10px 15px; 
        border-radius:8px; cursor:pointer; font-size:0.9rem; transition: 0.2s; 
        text-transform: uppercase; font-weight: bold;
    }
    button:active { transform: scale(0.95); background: #555; }
    
    .diff-toggle { background: #333; border: 1px solid #ffcc00; color: #ffcc00; }

    #overlay, #game-over {
        position: fixed; top:0; left:0; width:100%; height:100%;
        background: rgba(18,18,18,0.95); display:flex; flex-direction:column;
        justify-content:center; align-items:center; z-index:100; gap: 20px;
    }
    #game-over { display: none; background: rgba(40,0,0,0.9); }

    #level-banner {
        position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
        font-size:3rem; color:#ffcc00; opacity:0; transition:0.5s; pointer-events:none; z-index: 10;
    }
    .start-btn { font-size:1.5rem; background:#FF355E; width: 220px; }
    .restart-btn { font-size:1.5rem; background:#50BFE6; width: 220px; }
</style>
</head>

<body>
<div id="overlay">
    <h1 style="color:#ffcc00; margin-bottom: 0;">BRICK SHOOTER</h1>
    <p style="color: #aaa;">Clear ALL center blocks to win.</p>
    <button class="start-btn" onclick="startApp()">START GAME</button>
</div>

<div id="game-over">
    <h1 style="color:#FF355E; margin-bottom: 0;">GAME OVER</h1>
    <p id="final-stats" style="color: #ccc; font-size: 1.2rem;"></p>
    <button class="restart-btn" onclick="initGrid(false); document.getElementById('game-over').style.display='none';">TRY AGAIN</button>
</div>

<div id="level-banner">LEVEL COMPLETE</div>

<div class="stats">
    <span>LVL: <span id="level">1</span></span>
    <span>SCORE: <span id="score">0</span></span>
</div>

<div class="controls">
    <button class="diff-toggle" id="diff-btn" onclick="toggleDifficulty()">Difficulty: Easy</button>
    <button onclick="undo()">Undo</button>
    <button onclick="resetGame()">Reset</button>
</div>

<canvas id="gameCanvas" width="640" height="640"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const scoreEl = document.getElementById("score");
const levelEl = document.getElementById("level");
const banner = document.getElementById("level-banner");

const GRID = 16, TILE = 40;
const ALL_COLORS = ["#FF355E","#66FF66","#50BFE6", "#FFD700", "#FF8C00", "#A020F0"];

const DIFF_CONFIG = [
    { name: "EASY", colors: 3, densityBase: 0.18, sizeBase: 4, densityMax: 0.45 },
    { name: "NORMAL", colors: 4, densityBase: 0.35, sizeBase: 5, densityMax: 0.55 },
    { name: "HARD", colors: 5, densityBase: 0.50, sizeBase: 6, densityMax: 0.65 } 
];

let diffIdx = 0; 
let activeColors = ALL_COLORS.slice(0, DIFF_CONFIG[diffIdx].colors);
let grid=[], score=0, level=1, history=[];
let activeProjectile=null, pulse=0, shake=0, particles = [], isTransitioning = false, isProcessingMomentum = false;
let audioCtx;

window.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        undo();
    }
});

function toggleDifficulty() {
    diffIdx = (diffIdx + 1) % DIFF_CONFIG.length;
    const config = DIFF_CONFIG[diffIdx];
    activeColors = ALL_COLORS.slice(0, config.colors);
    document.getElementById('diff-btn').textContent = `Difficulty: ${config.name}`;
    score = 0; level = 1;
    initGrid(false); 
}

function startApp() {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
    document.getElementById('overlay').style.display = 'none';
    initGrid(false);
    loop();
}

function playSound(type) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    if (type === 'shoot') {
        osc.frequency.setValueAtTime(150, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        osc.start(); osc.stop(audioCtx.currentTime + 0.1);
    } else if (type === 'match') {
        osc.frequency.setValueAtTime(400, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        osc.start(); osc.stop(audioCtx.currentTime + 0.2);
    } else if (type === 'win') {
        osc.frequency.setValueAtTime(523, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1046, audioCtx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
        osc.start(); osc.stop(audioCtx.currentTime + 0.4);
    } else if (type === 'fail') {
        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.5);
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        osc.start(); osc.stop(audioCtx.currentTime + 0.5);
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        this.size = Math.random() * 4 + 2;
        this.vx = (Math.random() - 0.5) * 12;
        this.vy = (Math.random() - 0.5) * 12;
        this.life = 1.0;
        this.decay = Math.random() * 0.03 + 0.02;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life -= this.decay; this.vx *= 0.92; this.vy *= 0.92; }
    draw() { ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.size, this.size); }
}

function spawnParticles(x, y, color) {
    for(let i=0; i<15; i++) particles.push(new Particle(x * TILE + TILE/2, y * TILE + TILE/2, color));
}

function getValidColor(x, y) {
    let possibleColors = [...activeColors];
    if (grid[y] && grid[y][x-1]) possibleColors = possibleColors.filter(c => c !== grid[y][x-1].color);
    if (grid[y-1] && grid[y-1][x]) possibleColors = possibleColors.filter(c => c !== grid[y-1][x].color);
    return possibleColors.length > 0 ? possibleColors[Math.floor(Math.random() * possibleColors.length)] : activeColors[Math.floor(Math.random() * activeColors.length)];
}

function isShooterZone(x,y){
    const rowBand = y < 3 || y > 12;
    const colBand = x < 3 || x > 12;
    return (colBand && y >= 3 && y <= 12) || (rowBand && x >= 3 && x <= 12);
}

function isSpaceAvailable(x, y, dx, dy) {
    let nx = x + dx, ny = y + dy;
    if (grid[ny] && grid[ny][nx]) return false;
    let cx = nx, cy = ny;
    while (cx >= 0 && cx < GRID && cy >= 0 && cy < GRID) {
        if (isShooterZone(cx, cy)) return false; 
        if (grid[cy][cx] && cx >= 3 && cx <= 12 && cy >= 3 && cy <= 12) return true;
        cx += dx; cy += dy;
    }
    return false;
}

function initGrid(isNextLevelTrigger=false){
    if(!isNextLevelTrigger){ score = 0; level = 1; history = []; } else { history = []; }
    grid=[...Array(GRID)].map(()=>Array(GRID).fill(null));
    particles = [];

    for(let y=0; y<GRID; y++) for(let x=0; x<GRID; x++) if(isShooterZone(x,y)) grid[y][x] = { color: activeColors[Math.floor(Math.random()*activeColors.length)], isFixed: false };
    
    const config = DIFF_CONFIG[diffIdx];
    const size = Math.min(config.sizeBase + Math.floor(level/5), 10);
    const density = Math.min(config.densityBase + (level * 0.015), config.densityMax);
    const s = Math.floor((GRID-size)/2), e = s + size - 1;

    for(let y=s; y<=e; y++) {
        for(let x=s; x<=e; x++) {
            if(Math.random() < density) grid[y][x] = { color: getValidColor(x, y), isFixed: true };
        }
    }

    // Pre-clear logic
    let clearing = true;
    while(clearing) {
        let toDelete = [];
        for(let y=3; y<=12; y++) {
            for(let x=3; x<=12; x++) {
                if(!grid[y][x]) continue;
                let q=[[x,y]], seen=new Set([x+","+y]), col=grid[y][x].color;
                let stack = [[x,y]], visited = new Set([x+","+y]);
                while(stack.length){
                    let [cx,cy] = stack.pop();
                    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
                        let nx=cx+dx, ny=cy+dy;
                        if(nx>=3&&nx<=12&&ny>=3&&ny<=12&&grid[ny][nx]?.color===col&&!visited.has(nx+","+ny)){
                            visited.add(nx+","+ny); stack.push([nx,ny]);
                        }
                    });
                }
                if(visited.size >= 3) visited.forEach(p => toDelete.push(p));
            }
        }
        if(toDelete.length > 0) {
            toDelete.forEach(p => { let [dx, dy] = p.split(",").map(Number); grid[dy][dx] = null; });
        } else { clearing = false; }
    }

    updateUI();
    isTransitioning = false;
    isProcessingMomentum = false;
}

function updateUI(){ scoreEl.textContent=score; levelEl.textContent=level; }
function saveState(){ 
    if(isTransitioning) return;
    history.push({grid:JSON.parse(JSON.stringify(grid)), score}); 
    if(history.length > 50) history.shift(); 
}

function undo(){ 
    if(activeProjectile || history.length === 0 || isTransitioning) return; 
    let last = history.pop(); 
    grid = last.grid; score = last.score; 
    updateUI(); 
}

function resetGame(){ if(confirm("Reset Level and Score?")) initGrid(false); }

function handleInput(e) {
    if(activeProjectile || isTransitioning || isProcessingMomentum) return;
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    const x = Math.floor(((clientX - rect.left) / rect.width) * GRID);
    const y = Math.floor(((clientY - rect.top) / rect.height) * GRID);
    if(!grid[y]?.[x] || !isInnerEdge(x,y)) return;
    let dx=0, dy=0;
    if(x===2) dx=1; else if(x===13) dx=-1; else if(y===2) dy=1; else if(y===13) dy=-1;
    if (!isSpaceAvailable(x, y, dx, dy)) return;
    saveState();
    playSound('shoot');
    const color = grid[y][x].color;
    shiftShooterAway(x,y,dx,dy);
    startProjectile(x,y,dx,dy,color);
}

canvas.addEventListener("mousedown", handleInput);
canvas.addEventListener("touchstart", (e) => { e.preventDefault(); handleInput(e); }, {passive: false});

function isInnerEdge(x,y){ return (x===2||x===13)&&(y>=3&&y<=12) || (y===2||y===13)&&(x>=3&&x<=12); }

function startProjectile(x,y,dx,dy,color){
    let cx=x+dx, cy=y+dy, tx=x, ty=y, hit=false;
    while(cx >= 0 && cx < GRID && cy >= 0 && cy < GRID){
        if(isShooterZone(cx,cy)){ tx=cx; ty=cy; hit=true; break; }
        if(grid[cy][cx]){ break; }
        tx=cx; ty=cy; cx+=dx; cy+=dy;
    }
    activeProjectile={x:x*TILE, y:y*TILE, tx, ty, dx:dx*25, dy:dy*25, odx:dx, ody:dy, color, hit};
}

function shiftShooterAway(x,y,dx,dy){
    if(dx===1){ grid[y][2]=grid[y][1]; grid[y][1]=grid[y][0]; grid[y][0]={color:activeColors[Math.floor(Math.random()*activeColors.length)],isFixed:false}; }
    else if(dx===-1){ grid[y][13]=grid[y][14]; grid[y][14]=grid[y][15]; grid[y][15]={color:activeColors[Math.floor(Math.random()*activeColors.length)],isFixed:false}; }
    else if(dy===1){ grid[2][x]=grid[1][x]; grid[1][x]=grid[0][x]; grid[0][x]={color:activeColors[Math.floor(Math.random()*activeColors.length)],isFixed:false}; }
    else if(dy===-1){ grid[13][x]=grid[14][x]; grid[14][x]=grid[15][x]; grid[15][x]={color:activeColors[Math.floor(Math.random()*activeColors.length)],isFixed:false}; }
}

function absorbIntoShooter(x,y,dx,dy,color){
    const b={color, isFixed:false, lastDx:0, lastDy:0};
    if(dx===1){grid[y][15]=grid[y][14]; grid[y][14]=grid[y][13]; grid[y][13]=b;}
    else if(dx===-1){grid[y][0]=grid[y][1]; grid[y][1]=grid[y][2]; grid[y][2]=b;}
    else if(dy===1){grid[15][x]=grid[14][x]; grid[14][x]=grid[13][x]; grid[13][x]=b;}
    else if(dy===-1){grid[0][x]=grid[1][x]; grid[1][x]=grid[2][x]; grid[2][x]=b;}
}

function drawArrow(px, py, dx, dy) {
    const cx = px + TILE / 2; const cy = py + TILE / 2;
    ctx.strokeStyle = "rgba(255,255,255,0.9)"; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(cx - dx * 12, cy - dy * 12); ctx.lineTo(cx + dx * 12, cy + dy * 12);
    const headLen = 8; const angle = Math.atan2(dy, dx);
    ctx.lineTo(cx + dx * 12 - headLen * Math.cos(angle - Math.PI / 6), cy + dy * 12 - headLen * Math.sin(angle - Math.PI / 6));
    ctx.moveTo(cx + dx * 12, cy + dy * 12);
    ctx.lineTo(cx + dx * 12 - headLen * Math.cos(angle + Math.PI / 6), cy + dy * 12 - headLen * Math.sin(angle + Math.PI / 6));
    ctx.stroke();
}

function checkMatches(){
    let clear=new Set();
    for(let y=3;y<=12;y++) for(let x=3;x<=12;x++){
        if(!grid[y][x] || clear.has(x+","+y)) continue;
        let q=[[x,y]], seen=new Set([x+","+y]), col=grid[y][x].color;
        while(q.length){
            let [cx,cy]=q.pop();
            [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
                let nx=cx+dx, ny=cy+dy;
                if(nx>=3&&nx<=12&&ny>=3&&ny<=12&&grid[ny][nx]?.color===col&&!seen.has(nx+","+ny)){
                    seen.add(nx+","+ny); q.push([nx,ny]);
                }
            });
        }
        if(seen.size>=3) seen.forEach(p=>clear.add(p));
    }
    if(!clear.size) return false;
    shake = 10; playSound('match');
    clear.forEach(p=>{
        let[x,y]=p.split(",").map(Number);
        spawnParticles(x, y, grid[y][x].color);
        grid[y][x]=null; score+=10;
    });
    updateUI(); 
    isProcessingMomentum = true;
    setTimeout(processMomentum, 100); 
    return true;
}

function processMomentum(){
    let moved=false;
    for(let y=0;y<GRID;y++) for(let x=0;x<GRID;x++){
        const b=grid[y][x];
        if(!b || b.isFixed || (!b.lastDx && !b.lastDy)) continue;
        let cx=x, cy=y, nx=cx+b.lastDx, ny=cy+b.lastDy;
        if(nx>=0 && nx<GRID && ny>=0 && ny<GRID && isShooterZone(nx,ny)){
            absorbIntoShooter(nx,ny,b.lastDx,b.lastDy,b.color); grid[cy][cx]=null; moved=true; continue;
        }
        while(nx>=0 && nx<GRID && ny>=0 && ny<GRID && !grid[ny][nx]){
            grid[ny][nx]=b; grid[cy][cx]=null;
            cx=nx; cy=ny; nx+=b.lastDx; ny+=b.lastDy; moved=true;
            if(nx>=0 && nx<GRID && ny>=0 && ny<GRID && isShooterZone(nx,ny)){
                absorbIntoShooter(nx,ny,b.lastDx,b.lastDy,b.color); grid[cy][cx]=null; break;
            }
        }
    }
    if(moved) { if(!checkMatches()) setTimeout(processMomentum, 50); } 
    else { isProcessingMomentum = false; if (!checkWin()) checkGameOver(); }
}

function checkWin(){
    if(isTransitioning || activeProjectile || isProcessingMomentum) return false;
    let bricksInCenter = 0;
    for(let y=3; y<=12; y++) for(let x=3; x<=12; x++) if(grid[y][x]) bricksInCenter++;
    if(bricksInCenter === 0) { nextLevel(); return true; }
    return false;
}

function checkGameOver() {
    let anyPossibleShot = false;
    for (let i = 3; i <= 12; i++) {
        if (isSpaceAvailable(2, i, 1, 0) || isSpaceAvailable(13, i, -1, 0) || 
            isSpaceAvailable(i, 2, 0, 1) || isSpaceAvailable(i, 13, 0, -1)) { anyPossibleShot = true; break; }
    }
    if (!anyPossibleShot) {
        playSound('fail');
        document.getElementById('final-stats').textContent = `Final Score: ${score} | Level: ${level}`;
        document.getElementById('game-over').style.display = 'flex';
    }
}

function nextLevel(){
    isTransitioning = true;
    playSound('win'); banner.style.opacity=1;
    setTimeout(()=>{ banner.style.opacity=0; level++; initGrid(true); }, 1200);
}

function loop(){
    pulse+=.05;
    if(activeProjectile){
        activeProjectile.x += activeProjectile.dx;
        activeProjectile.y += activeProjectile.dy;
        let dist = Math.hypot(activeProjectile.x - activeProjectile.tx*TILE, activeProjectile.y - activeProjectile.ty*TILE);
        if(dist < 30){
            if(activeProjectile.hit) {
                absorbIntoShooter(activeProjectile.tx, activeProjectile.ty, activeProjectile.odx, activeProjectile.ody, activeProjectile.color);
                isProcessingMomentum = false; if(!checkWin()) checkGameOver();
            } else {
                grid[activeProjectile.ty][activeProjectile.tx] = { color: activeProjectile.color, isFixed: false, lastDx: activeProjectile.odx, lastDy: activeProjectile.ody };
                if(!checkMatches()) { processMomentum(); checkGameOver(); }
            }
            activeProjectile = null;
        }
    }
    ctx.save();
    if(shake > 0) { ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake); shake *= 0.9; }
    ctx.clearRect(0,0,640,640);
    for(let y=0;y<GRID;y++) for(let x=0;x<GRID;x++){
        let b=grid[y][x];
        if(b){
            ctx.fillStyle=b.color; ctx.fillRect(x*TILE+1,y*TILE+1,TILE-2,TILE-2);
            if(b.isFixed) {
                ctx.fillStyle = "rgba(255,255,255,0.3)"; ctx.beginPath();
                ctx.arc(x*TILE+20, y*TILE+20, 5 + Math.sin(pulse)*2, 0, Math.PI*2); ctx.fill();
            } 
            if(b.lastDx || b.lastDy) drawArrow(x*TILE, y*TILE, b.lastDx, b.lastDy);
        }
    }
    if(activeProjectile){ 
        ctx.fillStyle=activeProjectile.color; 
        ctx.fillRect(activeProjectile.x+1, activeProjectile.y+1, TILE-2, TILE-2); 
        drawArrow(activeProjectile.x, activeProjectile.y, activeProjectile.odx, activeProjectile.ody);
    }
    for(let i=particles.length-1; i>=0; i--) {
        particles[i].update(); particles[i].draw();
        if(particles[i].life <= 0) particles.splice(i, 1);
    }
    ctx.restore();
    requestAnimationFrame(loop);
}
</script>
</body>
</html>
